# Forth-ibE

В названии Forth-ibE вошло сокращение от слова in-built.

Тестирование/отладка интерпретатора Forth-ibE проводились на примерах учебника Броуди "Начальный курс программирования на языке Форт" до темы массивов. Ответы перепроверялись в интерпретаторе gforth. Результаты тестирования/отладки были оформлены в техническое условие (ТУ) на интерпретатор.

ТУ — это нормативный документ, который устанавливает требования к продукции, её производству, контролю, действует при отсутствии или в дополнение к обязательным стандартам.

ТУ на интерпретатор Forth-ibE.

1. В цикле REPL используется драйвер клавиатуры, построенный на стандартных средствах ввода/вывода языка Elixir, а не на драйвере клавиатуры как у оболочки команд ОС. Поэтому есть два отличия от gforth при вводе команд в режиме клавиатуры:

1) Окончание цепочки командных слов клавишей Enter реально переводит вывод на терминал на другую строку.

Например, в Forth-ibE:
Words: > 2 2
ok
Words: > * .
4 ok

В gforth:
2 2 ok
* . 4 ok

В gforth получается компактнее.

2) Нельзя перемещаться по набранной строке командных слов при помощи клавиш < и > для коррекции текста. Нельзя использовать клавишу ^ для повторного использования команды.

3. В gforth можно делить длинное определение на нескольких строках терминала, что составляет большое удобство при наборе большого определения.
В Forth-ibE это не реализовано по указанной выше причине. С другой стороны акцент работы в Forth-ibE делается не на терминал, а через API посылки сообщений.

4. Ввод слова с терминала в транслятор безразличен к регистру.
Можно ввести слово EMIT или emit, результат будет одинаков, т.к. в лексере текстовые токены приводятся к нижнему регистру.
По этой же причине имена переменных сохраняются в словаре строчными буквами.

5. Реализованы следующие пакеты встроенных функций выполнения слов:
io_words - слова ввода/вывода,
math_words - слова математических действий,
logic_words - слова логических операций,
flow_words - слова управления ветвлением программы
stack_words - слова действий со стеками,
interpret_words - слова действий в интерпретаторе.

Массивы не реализованы.
Описания пакетов кодируются во вспомогательных доступных файлах в формате Json.

6. Реализация ввода/вывода и обработки лексических конструкций выполнена в минимальном объеме учебника Броуди, т.к. интерпретатор планируется использовать в режиме обработки математических вычисления в рамках узлов связанных процессов. В режиме калькулятора имеющихся средств ввода/вывода достаточно для отладки кода.

7. В стандарте ANSI 94 отсутствует представление об унарном плюсе, поэтому в синтаксическом анализаторе интерпретатора Forth-ibE допускается только унарный минус, как и в интерпретаторе gforth.

Математические операции на стеке выполняются с числами, в том числе с плавающей точкой, поддерживаемыми компилятором Elixir. Поэтому целочисленные арифметические операции масштабирования forth над числами с плавающей точкой "заменены" арифметическими операциями с плавающей точкой Elixir.

8. По стандарту ANSI 94 реализованы логические слова поразрядных операций and, or, xor и not.
Добавлены функции более высокого уровня &and, &or и &not, которые являются кальками логических функций and, or и not над атомами true и false Elixir . Непротиворечива нотация &and, &or и &not взята из HTML.

Логические константы true и false во внутреннем представлении Forth-ibE переводятся во флаги Forth 0 и -1. Любое число, отличное от 0, также трактуется как true.

9. В книге Броуди сказано, что "оператор IF ... THEN должен содержаться только внутри определения (через двоеточие), так что вы не можете использовать его в режиме калькулятора."
В Forth-ibE в режиме калькулятора можно выполнять оператор IF ... THEN одного уровня. Для работы со сложными конструкциями IF ... THEN предлагается разбивать его определение на подопределения вложенных конструкций слов ветвления.

Например в gforth можно записать длинное определение так:
( вложенные конструкции IF ...THEN )
: КУПЮРЫ DUP 10 < IF ." Это уже долги " ELSE
DUP 200 <= IF ." МЕЛКИЕ " ELSE
DUP 1000 <= IF ." СРЕДНИЕ " ELSE
DUP 5000 <= IF ." Крупные " ELSE
." мы таких не видели "
THEN THEN THEN THEN DROP ;

В Forth-ibE этот же результат достигается следующим образом:
( разложение конструкции вложенных IF ...THEN на определения )
: КРУПНЫЕ DUP 5000 <= IF ." Крупные " ELSE ." мы таких не видели " THEN ;
: СРЕДНИЕ DUP 1000 <= IF ." СРЕДНИЕ " ELSE КРУПНЫЕ THEN ;
: МЕЛКИЕ DUP 200 <= IF ." МЕЛКИЕ " ELSE СРЕДНИЕ THEN ;
: КУПЮРЫ DUP 10 < IF ." Это уже долги " ELSE МЕЛКИЕ THEN DROP ;

10. Реализации слова ?DO...LOOP цикла с начальной проверкой совпадения границы и индекса не потребовалось: работает простой цикл DO...LOOP.

Цикл BEGIN...WHILE...REPEAT и выход из цикла LEAVE в настоящей версии Forth-ibE не реализованы. Есть цикл с условием BEGIN...UNTIL.

11. Есть два сходных слова: QUIT и ABORT. Слово QUIT вызывает прекращение работы программы, но не очищает стек. Слово ABORT выполняет те же действия, что и QUIT, но очищает стек.

12. Характеристика возможных программирования ошибок в Forth-ibE, их выявление и диагностика.

Ошибки синтаксиса.
Ошибки лексического анализа кода forth возможны, т.к. базовые слова, имхо, сочинялись без какой-либо систематизации и правил. Единственное правило - это разделение слов пробельными символами. Поэтому теоретически трудно описать конечный автомат разбора синтаксиса, учитывающего множество вариантов комбинаций символов.

Примеры неоднозначности трактования символов лексером:
ABORT" означает слово, которое по определению выполняет ABORT и вывод заданного за ним текста, т.е. " можно считать открывающей кавычкой.
STAR" может быть последним словом, например, во фрагменте
." Follow your STAR"
В этом случае " считается закрывающей кавычкой, ограничивающей текст.

Чтобы избежать такой неоднозначности и не усложнять синтаксический анализатор в Forth-ibE следует строго придерживаться правила разделения слов пробельными символами, т.е. рассмотренную команду следует записать так:
." Follow your star "

Согласно духа учебника Броуди закрывающая кавычка не является словом, так же как закрывающая скобка ) комментария. Мы же предлагаем для однообразия считать их словами, не нарушая семантики языка.

Ошибки преобразования токенов в код.
При синтаксическом анализе в интерпретаторе токены получают семантику. Оценивать правильность принятых семантических решений будет уже движок.

Ошибки времени выполнения движка.
Лексические и синтаксические ошибки сказываются на последнем этапе выполнения virt-coda.

(Примечание. virt-code отличается от byte-code, т.к. построен на списке, содержащего более сложные конструкции, чем простой байт. Приставка virt можно понимать как сокращение слово virtual, а можно считать знаком уважения к Никлаусу Вирту.)

В движке Forth-ibE встроены очевидные блокировки выполнения недопустимых арифметических операций: деление на нуль, извлечение квадратного корня из отрицательного числа и ещё обращение к пустому стеку данных.
После вывода диагностики REPL возвращается к приёму слов.

13. В режиме интерпретатора Forth-ibE считывает во время сеанса ввод с клавиатуры в реальном времени и в цикле REPL обрабатывает введенные слова. Этот режим идеально подходит для отладки данных или команд. Режим REPL снисходителен к ошибкам, восстанавливая работу интерпретатор и предоставляя информацию о состоянии стека программы в случае ошибки.

Написание кода на Forth сопряжено с возможностью совершения ошибок по простому недосмотру и основная точка проявления ошибки располагается в стеке. Например, по невнимательности можно подать в стек неполное количество данных. Приведем пример ошибки:
2 * .

Для защиты от грубых ошибок в приложении Forth-ibE применяется приём защитного программирования на базе оператора Elixir
try do ... catch ... end
Для одиночного процесса интерпретатора этого достаточно.

Предупреждение об ошибке выводится в следующем виде:
Words $ 2 * .
Ошибка:
    Код: [2, :mult, :dot]
    Стек: [ ]
    Стек возврата: [ ]
Words $

После вывода предупреждения интерпретатор снова переходит к приёму слов.

В дальнейшем в API Forth-ibE защита от грубых ошибок будет построена на основе супервизора Elixir, реализующего стандартную стратегии OPT "Let it crash!".

14. Исходный код интерпретатора Forth-ibE является открытым. Промышленный релиз пока не был подготовлен по причине продолжения разработки.

Интерпретатор Forth-ibE запускается в режиме разработчика командой:
mix run —no-halt

А завершение работы интерпретатора производится стандартным словом:
bye

15. Чтобы завершить рассмотрение ТУ разберем важную тему переменных и констант Forth-ibE.
Cвойства переменных и констант соответствуют стандартным, но их таблица реализована на базе словаря Map в Elixir. Это накладывает определенные ограничения на реализацию, например, невозможно в ячейке словаря сохранить переменную, константу или слово под одним именем.

Поведение константы и переменной отличаются друг от друга: переменная по имени в стеке "вытаскивается" из памяти словом @, а имя константы всегда в стеке подменяется интерпретатором её значением.
Допустим, переменная СЧЁТЧИК и константа ПРЕДЕЛ имеют значение 220. Тогда

СЧЁТЧИК @ .
220 ok

ПРЕДЕЛ .
220 ok

16. Дополнение к основному ТУ.

В Forth-ibE не предусмотрена смена основания системы счисления и постоянно равно 10.
Не реализованы массивы переменных по причине сложности осуществления векторизации ячеек словаря Map Elixir.

Слово RECURSE, которое осуществляет компиляцию адреса текущего определяемого слова, не реализовано по причине отсутствия указателей в языке Elixir. Но рекурсия работает!
В учебнике Броуди есть следующий пример на рекурсию:

VARIABLE СЧЕТЧИК
: ПРЕДЛОЖЕНИЕ CR ." Спрашивайте, пожалуйста! " -1 СЧЕТЧИК +! СЧЕТЧИК @ IF RECURSE THEN ;
3 СЧЕТЧИК !

Заменяем вторую фразу без лишних ухищрений на
: ПРЕДЛОЖЕНИЕ CR ." Спрашивайте, пожалуйста! " -1 СЧЕТЧИК +! СЧЕТЧИК @ IF ПОЧЕМУ THEN ;

и вуаля:

Words $ ПРЕДЛОЖЕНИЕ
Спрашивайте, пожалуйста!
Спрашивайте, пожалуйста!
Спрашивайте, пожалуйста! ok

